// useChat.js
import { useState, useEffect, useRef } from "react";
import { GoogleGenerativeAI } from "@google/generative-ai";

const API_KEY = process.env.NEXT_PUBLIC_GENAI_API_KEY;
const genAI = new GoogleGenerativeAI(API_KEY);
const MAX_REQUESTS = 5; // Maximum number of requests in queue to prevent overloading

export default function useChat() {
  const [chatHistory, setChatHistory] = useState([]);
  const [suggestedResponses, setSuggestedResponses] = useState([]);
  const [isLoading, setIsLoading] = useState(false); // Add isLoading state
  const requestQueue = useRef([]);

  useEffect(() => {
    const processUserInput = async () => {
      if (requestQueue.current.length > 0) {
        setIsLoading(true); // Set isLoading to true when processing user input
        const userInput = requestQueue.current[0];
        await generateResponse(userInput);
        requestQueue.current = requestQueue.current.slice(1);
        setIsLoading(false); // Set isLoading to false after generating response
      }
    };
    processUserInput();
  }, [requestQueue.current]);

  const generateResponse = async (userInput) => {
    if (!userInput.trim()) {
      throw new Error("User input cannot be empty");
    }
  
    const model = genAI.getGenerativeModel({ model: "gemini-pro" });
    const conversationHistory = chatHistory.map(chat => `User: ${chat.user}`).join('\n');
    const prompt = `${conversationHistory}\n\nMy friend said "${userInput}". Here's the context of our conversation and why I need help coming up with a reply. Please only provide a maximum of 3 numbered suggestions for how I could respond: \n`; 
  
    let result;
    let attempts = 0;
  
    while (!result && attempts < MAX_REQUESTS) {
      try {
        result = await model.generateContent(prompt);
      } catch (error) {
        if (error.message.includes('overloaded','No')) {
          attempts++;
          await new Promise(resolve => setTimeout(resolve, 1000 * attempts)); // Wait for some time before retrying
        } else {
          throw error; // If it's not an overload error, throw it
        }
      }
    }
  
    let botResponse = await result.response;
  
    // Only update chat history and suggested responses if a valid response was generated
    if (botResponse && botResponse.text()) {
      setChatHistory(prevChatHistory => [...prevChatHistory, { user: userInput, bot: botResponse.text() }]);
      setSuggestedResponses(parseSuggestions(botResponse.text()));
    } else {
      console.warn("No text was generated by the AI model.");
    }
  };
  
  const handleUserInput = (userInput) => {
    if (requestQueue.current.length < MAX_REQUESTS) {
      setChatHistory(prevChatHistory => [...prevChatHistory, { user: userInput }]);
      requestQueue.current = [...requestQueue.current, userInput];
    } else {
      console.warn("Request queue is full. Please wait for some requests to complete.");
    }
  };

  const parseSuggestions = (responseText) => {
    const regex = /^\d+\.\s+(.*?)(?:\s*<br\s*\/?>\s*|$)/gm; 
    const matches = responseText.matchAll(regex);
    const suggestions = [];
  
    for (const match of matches) {
      if (suggestions.length >= 5) break; 
      let suggestion = match[1].replace(/\s*<br\s*\/?>\s*/g, ' ').trim(); 
      suggestion = suggestion.replace(/^(["'])(.*)\1$/, '$2'); // Remove quotes
  
      suggestions.push(suggestion); 
    }
  
    return suggestions;
  };
  
  
  

  return { chatHistory, suggestedResponses, handleUserInput, setSuggestedResponses, isLoading  };
}
